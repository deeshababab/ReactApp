{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = createAnimatedComponent;\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _reactNative = require(\"react-native\");\n\nvar _ReanimatedEventEmitter = _interopRequireDefault(require(\"./ReanimatedEventEmitter\"));\n\nvar _AnimatedEvent = _interopRequireDefault(require(\"./core/AnimatedEvent\"));\n\nvar _AnimatedNode = _interopRequireDefault(require(\"./core/AnimatedNode\"));\n\nvar _AnimatedProps = require(\"./core/AnimatedProps\");\n\nvar _invariant = _interopRequireDefault(require(\"fbjs/lib/invariant\"));\n\nvar _jsxFileName = \"E:\\\\react-native-starter-master\\\\react-native-starter-master\\\\node_modules\\\\react-native-ui-lib\\\\node_modules\\\\react-native-reanimated\\\\src\\\\createAnimatedComponent.js\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nvar NODE_MAPPING = new Map();\n\nfunction listener(data) {\n  var component = NODE_MAPPING.get(data.viewTag);\n  component && component._updateFromNative(data.props);\n}\n\nfunction createAnimatedComponent(Component) {\n  (0, _invariant.default)(typeof Component !== 'function' || Component.prototype && Component.prototype.isReactComponent, '`createAnimatedComponent` does not support stateless functional components; ' + 'use a class component instead.');\n\n  var AnimatedComponent = function (_React$Component) {\n    (0, _inherits2.default)(AnimatedComponent, _React$Component);\n\n    var _super = _createSuper(AnimatedComponent);\n\n    function AnimatedComponent() {\n      var _this;\n\n      (0, _classCallCheck2.default)(this, AnimatedComponent);\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      _this = _super.call.apply(_super, [this].concat(args));\n      _this._invokeAnimatedPropsCallbackOnMount = false;\n\n      _this._animatedPropsCallback = function () {\n        if (_this._component == null) {\n          _this._invokeAnimatedPropsCallbackOnMount = true;\n        } else if (typeof _this._component.setNativeProps !== 'function') {\n          _this.forceUpdate();\n        } else {\n          _this._component.setNativeProps(_this._propsAnimated.__getValue());\n        }\n      };\n\n      _this._setComponentRef = function (c) {\n        if (c !== _this._component) {\n          _this._component = c;\n        }\n      };\n\n      return _this;\n    }\n\n    (0, _createClass2.default)(AnimatedComponent, [{\n      key: \"componentWillUnmount\",\n      value: function componentWillUnmount() {\n        this._detachPropUpdater();\n\n        this._propsAnimated && this._propsAnimated.__detach();\n\n        this._detachNativeEvents();\n      }\n    }, {\n      key: \"setNativeProps\",\n      value: function setNativeProps(props) {\n        this._component.setNativeProps(props);\n      }\n    }, {\n      key: \"componentWillMount\",\n      value: function componentWillMount() {\n        this._attachProps(this.props);\n      }\n    }, {\n      key: \"componentDidMount\",\n      value: function componentDidMount() {\n        if (this._invokeAnimatedPropsCallbackOnMount) {\n          this._invokeAnimatedPropsCallbackOnMount = false;\n\n          this._animatedPropsCallback();\n        }\n\n        this._propsAnimated.setNativeView(this._component);\n\n        this._attachNativeEvents();\n\n        this._attachPropUpdater();\n      }\n    }, {\n      key: \"_getEventViewRef\",\n      value: function _getEventViewRef() {\n        return this._component.getScrollableNode ? this._component.getScrollableNode() : this._component;\n      }\n    }, {\n      key: \"_attachNativeEvents\",\n      value: function _attachNativeEvents() {\n        var node = this._getEventViewRef();\n\n        for (var key in this.props) {\n          var prop = this.props[key];\n\n          if (prop instanceof _AnimatedEvent.default) {\n            prop.attachEvent(node, key);\n          }\n        }\n      }\n    }, {\n      key: \"_detachNativeEvents\",\n      value: function _detachNativeEvents() {\n        var node = this._getEventViewRef();\n\n        for (var key in this.props) {\n          var prop = this.props[key];\n\n          if (prop instanceof _AnimatedEvent.default) {\n            prop.detachEvent(node, key);\n          }\n        }\n      }\n    }, {\n      key: \"_reattachNativeEvents\",\n      value: function _reattachNativeEvents(prevProps) {\n        var node = this._getEventViewRef();\n\n        var attached = new Set();\n        var nextEvts = new Set();\n\n        for (var key in this.props) {\n          var prop = this.props[key];\n\n          if (prop instanceof _AnimatedEvent.default) {\n            nextEvts.add(prop.__nodeID);\n          }\n        }\n\n        for (var _key2 in prevProps) {\n          var _prop = this.props[_key2];\n\n          if (_prop instanceof _AnimatedEvent.default) {\n            if (!nextEvts.has(_prop.__nodeID)) {\n              _prop.detachEvent(node, _key2);\n            } else {\n              attached.add(_prop.__nodeID);\n            }\n          }\n        }\n\n        for (var _key3 in this.props) {\n          var _prop2 = this.props[_key3];\n\n          if (_prop2 instanceof _AnimatedEvent.default && !attached.has(_prop2.__nodeID)) {\n            _prop2.attachEvent(node, _key3);\n          }\n        }\n      }\n    }, {\n      key: \"_attachProps\",\n      value: function _attachProps(nextProps) {\n        var oldPropsAnimated = this._propsAnimated;\n        this._propsAnimated = (0, _AnimatedProps.createOrReusePropsNode)(nextProps, this._animatedPropsCallback, oldPropsAnimated);\n\n        if (oldPropsAnimated !== this._propsAnimated) {\n          oldPropsAnimated && oldPropsAnimated.__detach();\n        }\n      }\n    }, {\n      key: \"_updateFromNative\",\n      value: function _updateFromNative(props) {\n        this._component.setNativeProps(props);\n      }\n    }, {\n      key: \"_attachPropUpdater\",\n      value: function _attachPropUpdater() {\n        var viewTag = (0, _reactNative.findNodeHandle)(this);\n        NODE_MAPPING.set(viewTag, this);\n\n        if (NODE_MAPPING.size === 1) {\n          _ReanimatedEventEmitter.default.addListener('onReanimatedPropsChange', listener);\n        }\n      }\n    }, {\n      key: \"_detachPropUpdater\",\n      value: function _detachPropUpdater() {\n        var viewTag = (0, _reactNative.findNodeHandle)(this);\n        NODE_MAPPING.delete(viewTag);\n\n        if (NODE_MAPPING.size === 0) {\n          _ReanimatedEventEmitter.default.removeAllListeners('onReanimatedPropsChange');\n        }\n      }\n    }, {\n      key: \"componentDidUpdate\",\n      value: function componentDidUpdate(prevProps) {\n        this._attachProps(this.props);\n\n        this._reattachNativeEvents(prevProps);\n\n        this._propsAnimated.setNativeView(this._component);\n      }\n    }, {\n      key: \"_filterNonAnimatedStyle\",\n      value: function _filterNonAnimatedStyle(inputStyle) {\n        var style = {};\n\n        for (var key in inputStyle) {\n          var value = inputStyle[key];\n\n          if (!(value instanceof _AnimatedNode.default) && key !== 'transform') {\n            style[key] = value;\n          }\n        }\n\n        return style;\n      }\n    }, {\n      key: \"_filterNonAnimatedProps\",\n      value: function _filterNonAnimatedProps(inputProps) {\n        var props = {};\n\n        for (var key in inputProps) {\n          var value = inputProps[key];\n\n          if (key === 'style') {\n            props[key] = this._filterNonAnimatedStyle(_reactNative.StyleSheet.flatten(value));\n          } else if (!(value instanceof _AnimatedNode.default)) {\n            props[key] = value;\n          }\n        }\n\n        return props;\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var props = this._filterNonAnimatedProps(this.props);\n\n        return _react.default.createElement(Component, (0, _extends2.default)({}, props, {\n          ref: this._setComponentRef,\n          collapsable: false,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 217,\n            columnNumber: 9\n          }\n        }));\n      }\n    }, {\n      key: \"getNode\",\n      value: function getNode() {\n        return this._component;\n      }\n    }]);\n    return AnimatedComponent;\n  }(_react.default.Component);\n\n  return AnimatedComponent;\n}","map":{"version":3,"sources":["E:/react-native-starter-master/react-native-starter-master/node_modules/react-native-ui-lib/node_modules/react-native-reanimated/src/createAnimatedComponent.js"],"names":["NODE_MAPPING","Map","listener","data","component","get","viewTag","_updateFromNative","props","createAnimatedComponent","Component","prototype","isReactComponent","AnimatedComponent","_invokeAnimatedPropsCallbackOnMount","_animatedPropsCallback","_component","setNativeProps","forceUpdate","_propsAnimated","__getValue","_setComponentRef","c","_detachPropUpdater","__detach","_detachNativeEvents","_attachProps","setNativeView","_attachNativeEvents","_attachPropUpdater","getScrollableNode","node","_getEventViewRef","key","prop","AnimatedEvent","attachEvent","detachEvent","prevProps","attached","Set","nextEvts","add","__nodeID","has","nextProps","oldPropsAnimated","set","size","ReanimatedEventEmitter","addListener","delete","removeAllListeners","_reattachNativeEvents","inputStyle","style","value","AnimatedNode","inputProps","_filterNonAnimatedStyle","StyleSheet","flatten","_filterNonAnimatedProps","React"],"mappings":"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","sourcesContent":["import React from 'react';\nimport { findNodeHandle, StyleSheet } from 'react-native';\nimport ReanimatedEventEmitter from './ReanimatedEventEmitter';\n\nimport AnimatedEvent from './core/AnimatedEvent';\nimport AnimatedNode from './core/AnimatedNode';\nimport { createOrReusePropsNode } from './core/AnimatedProps';\n\nimport invariant from 'fbjs/lib/invariant';\n\nconst NODE_MAPPING = new Map();\n\nfunction listener(data) {\n  const component = NODE_MAPPING.get(data.viewTag);\n  component && component._updateFromNative(data.props);\n}\n\nexport default function createAnimatedComponent(Component) {\n  invariant(\n    typeof Component !== 'function' ||\n      (Component.prototype && Component.prototype.isReactComponent),\n    '`createAnimatedComponent` does not support stateless functional components; ' +\n      'use a class component instead.'\n  );\n\n  class AnimatedComponent extends React.Component {\n    _invokeAnimatedPropsCallbackOnMount = false;\n\n    componentWillUnmount() {\n      this._detachPropUpdater();\n      this._propsAnimated && this._propsAnimated.__detach();\n      this._detachNativeEvents();\n    }\n\n    setNativeProps(props) {\n      this._component.setNativeProps(props);\n    }\n\n    componentWillMount() {\n      this._attachProps(this.props);\n    }\n\n    componentDidMount() {\n      if (this._invokeAnimatedPropsCallbackOnMount) {\n        this._invokeAnimatedPropsCallbackOnMount = false;\n        this._animatedPropsCallback();\n      }\n\n      this._propsAnimated.setNativeView(this._component);\n      this._attachNativeEvents();\n      this._attachPropUpdater();\n    }\n\n    _getEventViewRef() {\n      // Make sure to get the scrollable node for components that implement\n      // `ScrollResponder.Mixin`.\n      return this._component.getScrollableNode\n        ? this._component.getScrollableNode()\n        : this._component;\n    }\n\n    _attachNativeEvents() {\n      const node = this._getEventViewRef();\n\n      for (const key in this.props) {\n        const prop = this.props[key];\n        if (prop instanceof AnimatedEvent) {\n          prop.attachEvent(node, key);\n        }\n      }\n    }\n\n    _detachNativeEvents() {\n      const node = this._getEventViewRef();\n\n      for (const key in this.props) {\n        const prop = this.props[key];\n        if (prop instanceof AnimatedEvent) {\n          prop.detachEvent(node, key);\n        }\n      }\n    }\n\n    _reattachNativeEvents(prevProps) {\n      const node = this._getEventViewRef();\n      const attached = new Set();\n      const nextEvts = new Set();\n      for (const key in this.props) {\n        const prop = this.props[key];\n        if (prop instanceof AnimatedEvent) {\n          nextEvts.add(prop.__nodeID);\n        }\n      }\n      for (const key in prevProps) {\n        const prop = this.props[key];\n        if (prop instanceof AnimatedEvent) {\n          if (!nextEvts.has(prop.__nodeID)) {\n            // event was in prev props but not in current props, we detach\n            prop.detachEvent(node, key);\n          } else {\n            // event was in prev and is still in current props\n            attached.add(prop.__nodeID);\n          }\n        }\n      }\n      for (const key in this.props) {\n        const prop = this.props[key];\n        if (prop instanceof AnimatedEvent && !attached.has(prop.__nodeID)) {\n          // not yet attached\n          prop.attachEvent(node, key);\n        }\n      }\n    }\n\n    // The system is best designed when setNativeProps is implemented. It is\n    // able to avoid re-rendering and directly set the attributes that changed.\n    // However, setNativeProps can only be implemented on native components\n    // If you want to animate a composite component, you need to re-render it.\n    // In this case, we have a fallback that uses forceUpdate.\n    _animatedPropsCallback = () => {\n      if (this._component == null) {\n        // AnimatedProps is created in will-mount because it's used in render.\n        // But this callback may be invoked before mount in async mode,\n        // In which case we should defer the setNativeProps() call.\n        // React may throw away uncommitted work in async mode,\n        // So a deferred call won't always be invoked.\n        this._invokeAnimatedPropsCallbackOnMount = true;\n      } else if (typeof this._component.setNativeProps !== 'function') {\n        this.forceUpdate();\n      } else {\n        this._component.setNativeProps(this._propsAnimated.__getValue());\n      }\n    };\n\n    _attachProps(nextProps) {\n      const oldPropsAnimated = this._propsAnimated;\n\n      this._propsAnimated = createOrReusePropsNode(\n        nextProps,\n        this._animatedPropsCallback,\n        oldPropsAnimated\n      );\n      // If prop node has been reused we don't need to call into \"__detach\"\n      if (oldPropsAnimated !== this._propsAnimated) {\n        // When you call detach, it removes the element from the parent list\n        // of children. If it goes to 0, then the parent also detaches itself\n        // and so on.\n        // An optimization is to attach the new elements and THEN detach the old\n        // ones instead of detaching and THEN attaching.\n        // This way the intermediate state isn't to go to 0 and trigger\n        // this expensive recursive detaching to then re-attach everything on\n        // the very next operation.\n        oldPropsAnimated && oldPropsAnimated.__detach();\n      }\n    }\n\n    _updateFromNative(props) {\n      this._component.setNativeProps(props);\n    }\n\n    _attachPropUpdater() {\n      const viewTag = findNodeHandle(this);\n      NODE_MAPPING.set(viewTag, this);\n      if (NODE_MAPPING.size === 1) {\n        ReanimatedEventEmitter.addListener('onReanimatedPropsChange', listener);\n      }\n    }\n\n    _detachPropUpdater() {\n      const viewTag = findNodeHandle(this);\n      NODE_MAPPING.delete(viewTag);\n      if (NODE_MAPPING.size === 0) {\n        ReanimatedEventEmitter.removeAllListeners('onReanimatedPropsChange');\n      }\n    }\n\n    componentDidUpdate(prevProps) {\n      this._attachProps(this.props);\n      this._reattachNativeEvents(prevProps);\n\n      this._propsAnimated.setNativeView(this._component);\n    }\n\n    _setComponentRef = c => {\n      if (c !== this._component) {\n        this._component = c;\n      }\n    };\n\n    _filterNonAnimatedStyle(inputStyle) {\n      const style = {};\n      for (const key in inputStyle) {\n        const value = inputStyle[key];\n        if (!(value instanceof AnimatedNode) && key !== 'transform') {\n          style[key] = value;\n        }\n      }\n      return style;\n    }\n\n    _filterNonAnimatedProps(inputProps) {\n      const props = {};\n      for (const key in inputProps) {\n        const value = inputProps[key];\n        if (key === 'style') {\n          props[key] = this._filterNonAnimatedStyle(StyleSheet.flatten(value));\n        } else if (!(value instanceof AnimatedNode)) {\n          props[key] = value;\n        }\n      }\n      return props;\n    }\n\n    render() {\n      const props = this._filterNonAnimatedProps(this.props);\n      return (\n        <Component {...props} ref={this._setComponentRef} collapsable={false} />\n      );\n    }\n\n    // A third party library can use getNode()\n    // to get the node reference of the decorated component\n    getNode() {\n      return this._component;\n    }\n  }\n\n  return AnimatedComponent;\n}\n"]},"metadata":{},"sourceType":"script"}